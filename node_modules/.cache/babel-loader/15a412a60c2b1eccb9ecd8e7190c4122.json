{"ast":null,"code":"import { extends as _extends } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport Container from './container.js';\n\nclass Animated extends React.PureComponent {\n  static propTypes = {\n    getChildren: PropTypes.func.isRequired,\n    keyProp: PropTypes.string.isRequired,\n    links: PropTypes.array.isRequired,\n    nodes: PropTypes.array.isRequired,\n    duration: PropTypes.number.isRequired,\n    easing: PropTypes.func.isRequired,\n    steps: PropTypes.number.isRequired\n  };\n\n  constructor(props) {\n    super(props); // If we are animating, we set the initial positions of the nodes and links to be the position of the root node\n    // and animate from there\n\n    let initialX = props.nodes[0].x;\n    let initialY = props.nodes[0].y;\n    this.state = {\n      nodes: props.nodes.map(n => ({ ...n,\n        x: initialX,\n        y: initialY\n      })),\n      links: props.links.map(l => ({\n        source: { ...l.source,\n          x: initialX,\n          y: initialY\n        },\n        target: { ...l.target,\n          x: initialX,\n          y: initialY\n        }\n      }))\n    };\n  }\n\n  componentDidMount() {\n    this.animate();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.nodes === this.props.nodes && prevProps.links === this.props.links) {\n      return;\n    }\n\n    this.animate();\n  }\n\n  animate() {\n    // Stop previous animation if one is already in progress.  We will start the next animation\n    // from the position we are currently in\n    clearInterval(this.animation);\n    let counter = 0; // Do as much one-time calculation outside of the animation step, which needs to be fast\n\n    let animationContext = this.getAnimationContext(this.state, this.props);\n    this.animation = setInterval(() => {\n      counter++;\n\n      if (counter === this.props.steps) {\n        clearInterval(this.animation);\n        this.animation = null;\n        this.setState({\n          nodes: this.props.nodes,\n          links: this.props.links\n        });\n        return;\n      }\n\n      this.setState(this.calculateNewState(animationContext, counter / this.props.steps));\n    }, this.props.duration / this.props.steps);\n  }\n\n  getAnimationContext(initialState, newState) {\n    // Nodes/links that are in both states need to be moved from the old position to the new one\n    // Nodes/links only in the initial state are being removed, and should be moved to the position\n    // of the closest ancestor that still exists, or the new root\n    // Nodes/links only in the new state are being added, and should be moved from the position of\n    // the closest ancestor that previously existed, or the old root\n    // The base determines which node/link the data (like classes and labels) comes from for rendering\n    // We only run this once at the start of the animation, so optimisation is less important\n    let addedNodes = newState.nodes.filter(n1 => initialState.nodes.every(n2 => !this.areNodesSame(n1, n2))).map(n1 => ({\n      base: n1,\n      old: this.getClosestAncestor(n1, newState, initialState),\n      new: n1\n    }));\n    let changedNodes = newState.nodes.filter(n1 => initialState.nodes.some(n2 => this.areNodesSame(n1, n2))).map(n1 => ({\n      base: n1,\n      old: initialState.nodes.find(n2 => this.areNodesSame(n1, n2)),\n      new: n1\n    }));\n    let removedNodes = initialState.nodes.filter(n1 => newState.nodes.every(n2 => !this.areNodesSame(n1, n2))).map(n1 => ({\n      base: n1,\n      old: n1,\n      new: this.getClosestAncestor(n1, initialState, newState)\n    }));\n    let addedLinks = newState.links.filter(l1 => initialState.links.every(l2 => !this.areLinksSame(l1, l2))).map(l1 => ({\n      base: l1,\n      old: this.getClosestAncestor(l1.target, newState, initialState),\n      new: l1\n    }));\n    let changedLinks = newState.links.filter(l1 => initialState.links.some(l2 => this.areLinksSame(l1, l2))).map(l1 => ({\n      base: l1,\n      old: initialState.links.find(l2 => this.areLinksSame(l1, l2)),\n      new: l1\n    }));\n    let removedLinks = initialState.links.filter(l1 => newState.links.every(l2 => !this.areLinksSame(l1, l2))).map(l1 => ({\n      base: l1,\n      old: l1,\n      new: this.getClosestAncestor(l1.target, initialState, newState)\n    }));\n    return {\n      nodes: changedNodes.concat(addedNodes).concat(removedNodes),\n      links: changedLinks.concat(addedLinks).concat(removedLinks)\n    };\n  }\n\n  getClosestAncestor(node, stateWithNode, stateWithoutNode) {\n    let oldParent = node;\n\n    while (oldParent) {\n      let newParent = stateWithoutNode.nodes.find(n => this.areNodesSame(oldParent, n));\n\n      if (newParent) {\n        return newParent;\n      }\n\n      oldParent = stateWithNode.nodes.find(n => (this.props.getChildren(n) || []).some(c => this.areNodesSame(oldParent, c)));\n    }\n\n    return stateWithoutNode.nodes[0];\n  }\n\n  areNodesSame(a, b) {\n    return a.data[this.props.keyProp] === b.data[this.props.keyProp];\n  }\n\n  areLinksSame(a, b) {\n    return a.source.data[this.props.keyProp] === b.source.data[this.props.keyProp] && a.target.data[this.props.keyProp] === b.target.data[this.props.keyProp];\n  }\n\n  calculateNewState(animationContext, interval) {\n    return {\n      nodes: animationContext.nodes.map(n => this.calculateNodePosition(n.base, n.old, n.new, interval)),\n      links: animationContext.links.map(l => this.calculateLinkPosition(l.base, l.old, l.new, interval))\n    };\n  }\n\n  calculateNodePosition(node, start, end, interval) {\n    return { ...node,\n      x: this.calculateNewValue(start.x, end.x, interval),\n      y: this.calculateNewValue(start.y, end.y, interval)\n    };\n  }\n\n  calculateLinkPosition(link, start, end, interval) {\n    return {\n      source: { ...link.source,\n        x: this.calculateNewValue(start.source ? start.source.x : start.x, end.source ? end.source.x : end.x, interval),\n        y: this.calculateNewValue(start.source ? start.source.y : start.y, end.source ? end.source.y : end.y, interval)\n      },\n      target: { ...link.target,\n        x: this.calculateNewValue(start.target ? start.target.x : start.x, end.target ? end.target.x : end.x, interval),\n        y: this.calculateNewValue(start.target ? start.target.y : start.y, end.target ? end.target.y : end.y, interval)\n      }\n    };\n  }\n\n  calculateNewValue(start, end, interval) {\n    return start + (end - start) * this.props.easing(interval);\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(Container, _extends({}, this.props, this.state));\n  }\n\n}\n\nexport { Animated as default };","map":{"version":3,"names":["extends","_extends","PropTypes","React","Container","Animated","PureComponent","propTypes","getChildren","func","isRequired","keyProp","string","links","array","nodes","duration","number","easing","steps","constructor","props","initialX","x","initialY","y","state","map","n","l","source","target","componentDidMount","animate","componentDidUpdate","prevProps","clearInterval","animation","counter","animationContext","getAnimationContext","setInterval","setState","calculateNewState","initialState","newState","addedNodes","filter","n1","every","n2","areNodesSame","base","old","getClosestAncestor","new","changedNodes","some","find","removedNodes","addedLinks","l1","l2","areLinksSame","changedLinks","removedLinks","concat","node","stateWithNode","stateWithoutNode","oldParent","newParent","c","a","b","data","interval","calculateNodePosition","calculateLinkPosition","start","end","calculateNewValue","link","render","createElement","default"],"sources":["/home/r/ideaproject/react/rsite/node_modules/react-tree-graph/dist/module/components/animated.js"],"sourcesContent":["import { extends as _extends } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport Container from './container.js';\n\nclass Animated extends React.PureComponent {\n  static propTypes = {\n    getChildren: PropTypes.func.isRequired,\n    keyProp: PropTypes.string.isRequired,\n    links: PropTypes.array.isRequired,\n    nodes: PropTypes.array.isRequired,\n    duration: PropTypes.number.isRequired,\n    easing: PropTypes.func.isRequired,\n    steps: PropTypes.number.isRequired\n  };\n\n  constructor(props) {\n    super(props); // If we are animating, we set the initial positions of the nodes and links to be the position of the root node\n    // and animate from there\n\n    let initialX = props.nodes[0].x;\n    let initialY = props.nodes[0].y;\n    this.state = {\n      nodes: props.nodes.map(n => ({ ...n,\n        x: initialX,\n        y: initialY\n      })),\n      links: props.links.map(l => ({\n        source: { ...l.source,\n          x: initialX,\n          y: initialY\n        },\n        target: { ...l.target,\n          x: initialX,\n          y: initialY\n        }\n      }))\n    };\n  }\n\n  componentDidMount() {\n    this.animate();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.nodes === this.props.nodes && prevProps.links === this.props.links) {\n      return;\n    }\n\n    this.animate();\n  }\n\n  animate() {\n    // Stop previous animation if one is already in progress.  We will start the next animation\n    // from the position we are currently in\n    clearInterval(this.animation);\n    let counter = 0; // Do as much one-time calculation outside of the animation step, which needs to be fast\n\n    let animationContext = this.getAnimationContext(this.state, this.props);\n    this.animation = setInterval(() => {\n      counter++;\n\n      if (counter === this.props.steps) {\n        clearInterval(this.animation);\n        this.animation = null;\n        this.setState({\n          nodes: this.props.nodes,\n          links: this.props.links\n        });\n        return;\n      }\n\n      this.setState(this.calculateNewState(animationContext, counter / this.props.steps));\n    }, this.props.duration / this.props.steps);\n  }\n\n  getAnimationContext(initialState, newState) {\n    // Nodes/links that are in both states need to be moved from the old position to the new one\n    // Nodes/links only in the initial state are being removed, and should be moved to the position\n    // of the closest ancestor that still exists, or the new root\n    // Nodes/links only in the new state are being added, and should be moved from the position of\n    // the closest ancestor that previously existed, or the old root\n    // The base determines which node/link the data (like classes and labels) comes from for rendering\n    // We only run this once at the start of the animation, so optimisation is less important\n    let addedNodes = newState.nodes.filter(n1 => initialState.nodes.every(n2 => !this.areNodesSame(n1, n2))).map(n1 => ({\n      base: n1,\n      old: this.getClosestAncestor(n1, newState, initialState),\n      new: n1\n    }));\n    let changedNodes = newState.nodes.filter(n1 => initialState.nodes.some(n2 => this.areNodesSame(n1, n2))).map(n1 => ({\n      base: n1,\n      old: initialState.nodes.find(n2 => this.areNodesSame(n1, n2)),\n      new: n1\n    }));\n    let removedNodes = initialState.nodes.filter(n1 => newState.nodes.every(n2 => !this.areNodesSame(n1, n2))).map(n1 => ({\n      base: n1,\n      old: n1,\n      new: this.getClosestAncestor(n1, initialState, newState)\n    }));\n    let addedLinks = newState.links.filter(l1 => initialState.links.every(l2 => !this.areLinksSame(l1, l2))).map(l1 => ({\n      base: l1,\n      old: this.getClosestAncestor(l1.target, newState, initialState),\n      new: l1\n    }));\n    let changedLinks = newState.links.filter(l1 => initialState.links.some(l2 => this.areLinksSame(l1, l2))).map(l1 => ({\n      base: l1,\n      old: initialState.links.find(l2 => this.areLinksSame(l1, l2)),\n      new: l1\n    }));\n    let removedLinks = initialState.links.filter(l1 => newState.links.every(l2 => !this.areLinksSame(l1, l2))).map(l1 => ({\n      base: l1,\n      old: l1,\n      new: this.getClosestAncestor(l1.target, initialState, newState)\n    }));\n    return {\n      nodes: changedNodes.concat(addedNodes).concat(removedNodes),\n      links: changedLinks.concat(addedLinks).concat(removedLinks)\n    };\n  }\n\n  getClosestAncestor(node, stateWithNode, stateWithoutNode) {\n    let oldParent = node;\n\n    while (oldParent) {\n      let newParent = stateWithoutNode.nodes.find(n => this.areNodesSame(oldParent, n));\n\n      if (newParent) {\n        return newParent;\n      }\n\n      oldParent = stateWithNode.nodes.find(n => (this.props.getChildren(n) || []).some(c => this.areNodesSame(oldParent, c)));\n    }\n\n    return stateWithoutNode.nodes[0];\n  }\n\n  areNodesSame(a, b) {\n    return a.data[this.props.keyProp] === b.data[this.props.keyProp];\n  }\n\n  areLinksSame(a, b) {\n    return a.source.data[this.props.keyProp] === b.source.data[this.props.keyProp] && a.target.data[this.props.keyProp] === b.target.data[this.props.keyProp];\n  }\n\n  calculateNewState(animationContext, interval) {\n    return {\n      nodes: animationContext.nodes.map(n => this.calculateNodePosition(n.base, n.old, n.new, interval)),\n      links: animationContext.links.map(l => this.calculateLinkPosition(l.base, l.old, l.new, interval))\n    };\n  }\n\n  calculateNodePosition(node, start, end, interval) {\n    return { ...node,\n      x: this.calculateNewValue(start.x, end.x, interval),\n      y: this.calculateNewValue(start.y, end.y, interval)\n    };\n  }\n\n  calculateLinkPosition(link, start, end, interval) {\n    return {\n      source: { ...link.source,\n        x: this.calculateNewValue(start.source ? start.source.x : start.x, end.source ? end.source.x : end.x, interval),\n        y: this.calculateNewValue(start.source ? start.source.y : start.y, end.source ? end.source.y : end.y, interval)\n      },\n      target: { ...link.target,\n        x: this.calculateNewValue(start.target ? start.target.x : start.x, end.target ? end.target.x : end.x, interval),\n        y: this.calculateNewValue(start.target ? start.target.y : start.y, end.target ? end.target.y : end.y, interval)\n      }\n    };\n  }\n\n  calculateNewValue(start, end, interval) {\n    return start + (end - start) * this.props.easing(interval);\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(Container, _extends({}, this.props, this.state));\n  }\n\n}\n\nexport { Animated as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}